{"version":3,"sources":["webpack:///webpack/bootstrap fa4b28026b60fdd7aca3","webpack:///./src/sw.js","webpack:///./src/lib/core/ServiceWorkerRuntime.js","webpack:///./~/events/events.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA,mCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oEAAmE,aAAa;AAChF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA,EAAC;;AAED;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA,EAAC,E;;;;;;;ACvID;AACA;AACA,EAAC;AACD;;AAEA,iCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA,kDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,kDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,2CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;;AAEA;AACA,cAAa,EAAE;AACf,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe;AACf;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA,qBAAoB;;AAEpB;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC,uB;;;;;;;ACrQD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fa4b28026b60fdd7aca3","var _ServiceWorkerRuntime = require('./lib/core/ServiceWorkerRuntime');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// enable for localhost by default\nvar IS_DEBUG = location.hostname.toLowerCase() === 'localhost';\n\n// @todo abstract this\nfunction debug() {\n  if (IS_DEBUG) {\n    var _console;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, ['[ATM SW]'].concat(args));\n  }\n}\n\nvar runtime = new _ServiceWorkerRuntime.ServiceWorkerRuntime(self);\nvar ATM_HOSTS = ['localhost:8000', 'www.adtechmedia.io', 'demo.adtechmedia.io', 'adm.adtechmedia.io', 'api.adtechmedia.io', 'api-dev.adtechmedia.io'];\n\nvar originsVector = ATM_HOSTS.map(function (host) {\n  return 'https://' + host;\n}).concat(ATM_HOSTS.map(function (host) {\n  return 'http://' + host;\n}));\n\ndebug.apply(undefined, ['allowed origins'].concat(_toConsumableArray(originsVector)));\n\nfunction createFetch(runtime, event, fetchRequest) {\n  debug('start fetching ' + fetchRequest.url);\n\n  return fetch(fetchRequest).then(function (response) {\n\n    // Check if we received a valid response\n    if (!response || response.status !== 200 || response.type === 'error') {\n      debug('bad response for ' + fetchRequest.url, response, fetchRequest);\n\n      return response;\n    }\n\n    // IMPORTANT: Clone the response. A response is a stream\n    // and because we want the browser to consume the response\n    // as well as the cache consuming the response, we need\n    // to clone it so we have two streams.\n    var responseToCache = response.clone();\n\n    debug('update caches for ' + fetchRequest.url);\n\n    try {\n      if (!runtime.cache) {\n        throw new Error('worker\\'s cache is not initialized');\n      }\n\n      runtime.cache.put(event.request, responseToCache);\n    } catch (error) {\n      debug('update caches failed for ' + fetchRequest.url, error);\n    }\n\n    return response;\n  });\n}\n\n// log common events\nruntime.on(_ServiceWorkerRuntime.ServiceWorkerRuntime.INSTALL, function () {\n  return debug('installed');\n});\nruntime.on(_ServiceWorkerRuntime.ServiceWorkerRuntime.ACTIVATE, function () {\n  return debug('activated');\n});\nruntime.on(_ServiceWorkerRuntime.ServiceWorkerRuntime.INVALIDATE_CACHE, function () {\n  return debug('\\'' + runtime.cacheName + '\\' cache invalidated');\n});\nruntime.on(_ServiceWorkerRuntime.ServiceWorkerRuntime.ADD_TO_CACHE, function (assets) {\n  return debug.apply(undefined, ['assets added to cache'].concat(_toConsumableArray(assets)));\n});\n\nruntime.on(_ServiceWorkerRuntime.ServiceWorkerRuntime.MESSAGE, function (name, data) {\n  debug('message received:', name, '-->', data);\n\n  switch (name.toLowerCase()) {\n    case 'origin':\n      originsVector.push(data.toString());\n      break;\n    case 'debug':\n      IS_DEBUG = !!data;\n      break;\n    default:\n      break;\n  }\n});\n\nruntime.on(_ServiceWorkerRuntime.ServiceWorkerRuntime.FETCH, function (event) {\n\n  // IMPORTANT: Clone the request. A request is a stream and\n  // can only be consumed once. Since we are consuming this\n  // once by cache and once by the browser for fetch, we need\n  // to clone the response.\n  var fetchRequest = event.request.clone();\n\n  // Ignore not GET request.\n  if (fetchRequest.method !== 'GET') {\n    return;\n  }\n\n  var requestUrl = new URL(fetchRequest.url);\n\n  // Ignore unknown origins\n  if (originsVector.indexOf(requestUrl.origin) === -1) {\n    return;\n  }\n\n  debug('managing request to ' + fetchRequest.url);\n\n  event.respondWith(global.caches.match(event.request).then(function (response) {\n\n    // Cache hit - return response\n    if (response) {\n      debug('cached response for ' + fetchRequest.url);\n\n      // start updating caches in background so the \n      // next time will be a fresh result out there...\n      createFetch(runtime, event, fetchRequest);\n\n      return response;\n    }\n\n    return createFetch(runtime, event, fetchRequest);\n  }));\n});\n\nruntime.register().catch(function (error) {\n  return debug('Error', error);\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sw.js\n// module id = 0\n// module chunks = 0","Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServiceWorkerRuntime = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = require('events');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ServiceWorkerRuntime = exports.ServiceWorkerRuntime = function (_EventEmitter) {\n  _inherits(ServiceWorkerRuntime, _EventEmitter);\n\n  /**\n   * @param {*} context\n   * @param {String} cacheName\n   */\n  function ServiceWorkerRuntime(context) {\n    var cacheName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ServiceWorkerRuntime.CACHE_NAME;\n\n    _classCallCheck(this, ServiceWorkerRuntime);\n\n    var _this = _possibleConstructorReturn(this, (ServiceWorkerRuntime.__proto__ || Object.getPrototypeOf(ServiceWorkerRuntime)).call(this));\n\n    _this.context = context;\n    _this.cacheName = cacheName;\n    _this.cache = null;\n    return _this;\n  }\n\n  /**\n   * @returns {Promise|*}\n   */\n\n\n  _createClass(ServiceWorkerRuntime, [{\n    key: 'register',\n    value: function register() {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.once(ServiceWorkerRuntime.ACTIVATE, resolve);\n\n        _this2._registerInstall();\n        _this2._registerMsg();\n        _this2._registerFetch();\n        _this2._registerActivate();\n      });\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_registerInstall',\n    value: function _registerInstall() {\n      var _this3 = this;\n\n      this.context.addEventListener(ServiceWorkerRuntime.INSTALL, function (event) {\n        if (typeof _this3.context.skipWaiting === 'function') {\n          _this3.context.skipWaiting();\n        }\n\n        // atm event ServiceWorkerRuntime.INSTALL\n        _this3.emit(ServiceWorkerRuntime.INSTALL, event);\n      });\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_registerMsg',\n    value: function _registerMsg() {\n      var _this4 = this;\n\n      this.context.addEventListener(ServiceWorkerRuntime.MESSAGE, function (event) {\n        var data = { action: null };\n\n        try {\n          data = JSON.parse(event.data);\n        } catch (e) {}\n\n        switch (data.action.toLowerCase()) {\n          case ServiceWorkerRuntime.INVALIDATE_CACHE:\n            event.waitUntil(_this4._reloadCache(true));\n            break;\n          case ServiceWorkerRuntime.ADD_TO_CACHE:\n            if (data.payload) {\n              var assets = typeof data.payload === 'string' ? [data.payload] : data.payload;\n\n              _this4.cache.addAll(assets);\n\n              // atm event ServiceWorkerRuntime.ADD_TO_CACHE\n              _this4.emit(ServiceWorkerRuntime.ADD_TO_CACHE, assets, event.waitUntil);\n            }\n            break;\n          case ServiceWorkerRuntime.MESSAGE:\n            var payload = data.payload || {};\n\n            // atm event ServiceWorkerRuntime.MESSAGE\n            _this4.emit(ServiceWorkerRuntime.MESSAGE, payload.name || null, payload.data || null, event.waitUntil);\n            break;\n          default:\n            break;\n        }\n      });\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_registerFetch',\n    value: function _registerFetch() {\n      var _this5 = this;\n\n      this.context.addEventListener(ServiceWorkerRuntime.FETCH, function (event) {\n\n        // atm event ServiceWorkerRuntime.FETCH\n        _this5.emit(ServiceWorkerRuntime.FETCH, event);\n      });\n    }\n\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_registerActivate',\n    value: function _registerActivate() {\n      var _this6 = this;\n\n      this.context.addEventListener(ServiceWorkerRuntime.ACTIVATE, function (event) {\n        var supportsClaim = _this6.context.clients && typeof _this6.context.clients.claim === 'function';\n\n        var claimPromise = supportsClaim ? _this6.context.clients.claim() : Promise.resolve();\n\n        event.waitUntil(claimPromise.then(function () {\n          return _this6._reloadCache();\n        }).then(function () {\n\n          // atm event ServiceWorkerRuntime.ACTIVATE\n          _this6.emit(ServiceWorkerRuntime.ACTIVATE, event);\n\n          return Promise.resolve();\n        }));\n      });\n    }\n\n    /**\n     * @returns {Promise|*}\n     *\n     * @private\n     */\n\n  }, {\n    key: '_reloadCache',\n    value: function _reloadCache() {\n      var _this7 = this;\n\n      var clearSelf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      return global.caches.keys().then(function (cacheNames) {\n        var promises = cacheNames.filter(function (cacheName) {\n          return clearSelf || cacheName !== _this7.cacheName;\n        }).map(function (cacheName) {\n          return global.caches.delete(cacheName);\n        });\n\n        return Promise.all(promises);\n      }).then(function () {\n        return global.caches.open(_this7.cacheName);\n      }).then(function (cache) {\n        _this7.cache = cache;\n\n        // atm event ServiceWorkerRuntime.INVALIDATE_CACHE\n        _this7.emit(ServiceWorkerRuntime.INVALIDATE_CACHE);\n      });\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }], [{\n    key: 'INVALIDATE_CACHE',\n    get: function get() {\n      return 'invalidate-cache';\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: 'ADD_TO_CACHE',\n    get: function get() {\n      return 'add-to-cache';\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: 'MESSAGE',\n    get: function get() {\n      return 'message';\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: 'FETCH',\n    get: function get() {\n      return 'fetch';\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: 'INSTALL',\n    get: function get() {\n      return 'install';\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: 'ACTIVATE',\n    get: function get() {\n      return 'activate';\n    }\n\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: 'CACHE_NAME',\n    get: function get() {\n      return 'atm-sw-cache';\n    }\n  }]);\n\n  return ServiceWorkerRuntime;\n}(_events.EventEmitter);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/core/ServiceWorkerRuntime.js\n// module id = 1\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}